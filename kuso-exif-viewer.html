import customtkinter as ctk
from tkinterdnd2 import DND_FILES, TkinterDnD
from tkinter import filedialog, messagebox, Menu
from PIL import Image, ExifTags
import os
import platform
import glob
from datetime import datetime
import random
import threading
import time

# ==========================================
# CYBERPUNK THEME CONFIG
# ==========================================
CYBER_DARK = "#050a0e"
CYBER_BG_FRAME = "#111827"
CYBER_CYAN = "#00fff9"
CYBER_PINK = "#fe0056"
CYBER_YELLOW = "#fcec0c"
CYBER_GREEN = "#39ff14"
CYBER_TEXT_MAIN = "#e0f7fa"

FONT_TITLE = ("Impact", 20)
FONT_HEADER = ("Microsoft JhengHei UI", 16, "bold")
FONT_DATA = ("Consolas", 14)
FONT_BUTTON = ("Microsoft JhengHei UI", 16, "bold")
FONT_QUOTE = ("Microsoft JhengHei UI", 16, "bold") 

ctk.set_appearance_mode("Dark")

# --- æ”å½±æ¯’é›æ¹¯ ---
SOUL_QUOTES = [
    "ä½ ä¸æ˜¯å‡ç´šå™¨æï¼Œæ˜¯å»¶å¾Œé¢å°å¯¦åŠ›", "é˜²æ½®ç®±æ˜¯æ”å½±å¸«çš„å¤¢æƒ³å†°æ«ƒ", "å™¨æå…¨æ–°ï¼Œä½œå“å…¨ç„¡",
    "é¡é ­è¶Šè²´ï¼Œè¶Šä¸æ•¢å¸¶å‡ºé–€", "é¡é ­æ¯”ä½ çš„äººç”Ÿè¦åŠƒæ¸…æ¥š", "é–‹ç®±æ‹å¾—æ¯”ä½œå“èªçœŸ",
    "å™¨æè²·é½Šäº†ï¼Œæ‹ç…§é‚„åœ¨æ‰¾é¡Œæ", "ä½ ä¸æ˜¯å™¨æé»¨ï¼Œæ˜¯é€ƒé¿é»¨", "ç›¸æ©ŸçŸ¥é“ä½ å¾ˆçª®ï¼Œä½†ä½ è£ä½œä¸åœ¨ä¹",
    "æŠ€è¡“æ²’é€²æ­¥ï¼Œä½†é…ä»¶è¶Šä¾†è¶Šé½Š", "å…¨æ‰‹å‹•åªæ˜¯è®“éŒ¯èª¤æ›´æœ‰å°Šåš´", "ç”¨ M æ¨¡å¼æ‹çˆ›ï¼Œä¸æœƒæ¯”è¼ƒé«˜ç´š",
    "å…‰åœˆå…¨é–‹ä¸æ˜¯é¢¨æ ¼ï¼Œæ˜¯å¤±æ§", "å¿«é–€äº‚è½‰ï¼Œæ¨¡ç³Šç•¶å“²å­¸", "ISO çˆ†è¡¨ï¼Œå«æƒ…ç·’",
    "ä¸æœƒæ¸¬å…‰ï¼Œå»æ„›è«‡å…‰", "åƒæ•¸èƒŒå¾—ç†Ÿï¼Œç•«é¢é‚„æ˜¯æ­»", "ä½ åœ¨æ§åˆ¶ç›¸æ©Ÿï¼Œç›¸æ©Ÿåœ¨æ‡²ç½°ä½ ",
    "æ›å…‰è£œå„Ÿæ˜¯ä½ æœ€å¾Œçš„å¸Œæœ›", "ç™½å¹³è¡¡äº‚è·‘ï¼Œè‰²å½©é‚„æ•¢èªªã€Œè‡ªç„¶ã€", "æ¨¡ç³Šä¸æ˜¯è©©ï¼Œæ˜¯æ²’å°ç„¦",
    "é»‘ç™½ä¸æ˜¯æ·±åº¦ï¼Œæ˜¯é®ç¾", "æ¥µç°¡ä¸æ˜¯ä»€éº¼éƒ½æ²’æ‹åˆ°", "ç•™ç™½ç•™åˆ°åƒæ²’èµ°è¿‘",
    "å°ç¨±ä¸æ˜¯æ§‹åœ–ï¼Œæ˜¯æ€•å‡ºéŒ¯", "ä¸­å¤®æ§‹åœ–ç”¨ä¸€è¼©å­ï¼Œé‚„èªªæ˜¯é¢¨æ ¼", "å‰æ™¯äº‚æ”¾å«è¨­è¨ˆ",
    "å»£è§’è²¼è‡‰å«éœ‡æ’¼", "èƒŒæ™¯äº‚ä¸æ˜¯ç´€å¯¦ï¼Œæ˜¯ä¸è² è²¬", "çœ‹ä¸æ‡‚ä¸æ˜¯é«˜ç´šï¼Œæ˜¯æ²’èªªæ¸…æ¥š",
    "æ¨¡ç‰¹æ¼‚äº®ï¼Œä¸æ˜¯ä½ çš„åŠŸå‹", "æ•£æ™¯ä¸æ˜¯æƒ…æ„Ÿï¼Œæ˜¯èƒŒæ™¯ç³Šæ‰", "çœ¼ç¥ç©ºï¼Œä¸æ˜¯æ†‚é¬±ï¼Œæ˜¯æ²’å¼•å°",
    "æ¨¡ç‰¹åœ¨æ’ï¼Œä½ åœ¨è‡ªçˆ½", "å§¿å‹¢ä¸€æ¨£ï¼Œåªæ˜¯æ›äºº", "ä¿®çš®ä¿®åˆ°åƒå¡‘è† ï¼Œé‚„èªªçœŸå¯¦",
    "äººåƒä¸æ˜¯æ‹è‡‰éƒ¨è­‰ä»¶", "æ¨¡ç‰¹æ•‘äº†ä½ ï¼Œä½ é‚„ä»¥ç‚ºæ˜¯è‡ªå·±", "å·æ‹ä¸æ˜¯è¡—æ‹ï¼Œæ˜¯æ²’å‹‡æ°£",
    "è¢«æ‹’æ‹å°±èªªè‡ªå·±åœ¨åšè—è¡“", "å¾Œè£½ä¸æ˜¯å‰µä½œï¼Œæ˜¯æ€¥æ•‘", "æ¿¾é¡æ¯”å…§å®¹é‡",
    "é¡è‰²å¾ˆçŒ›ï¼Œæƒ…ç·’ç‚ºé›¶", "ä¿®åˆ°ä¸åƒäººï¼Œé‚„èªªè‡ªç„¶", "Lightroom ä¸æ˜¯è´–ç½ªåˆ¸",
    "ä¿®åœ–ä¿®åˆ°å¿˜è¨˜åŸæœ¬æƒ³æ‹ä»€éº¼", "å°æ¯”æ‹‰æ»¿ï¼Œæ•…äº‹æ¶ˆå¤±", "ä¸€éµé¢¨æ ¼ä¸æ˜¯é¢¨æ ¼",
    "HDR ä¸æ˜¯è®“äººçœ¼ç›æµè¡€", "å¾Œè£½æ™‚é–“æ¯”æ€è€ƒæ™‚é–“é•·", "æ²’é¢¨æ ¼ä¸å«å¤šå…ƒ",
    "æ¨¡ä»¿å¤ªåƒï¼Œå°±æ˜¯æŠ„", "æ¯å¼µéƒ½ä¸åŒï¼Œå…¶å¯¦éƒ½ä¸è¡Œ", "é»‘æš—ä¸æ˜¯æ·±æ²‰ï¼Œæ˜¯ç©º",
    "é¢¨æ ¼ä¸æ˜¯ä½ èªªäº†ç®—ï¼Œæ˜¯ä½œå“èªªäº†ç®—", "æ‹å¾ˆå¤šï¼Œä¸ä»£è¡¨æ‹å¾—å¥½", "å¿«é–€ç´¯ç©ï¼Œä¸ç­‰æ–¼æˆé•·",
    "ä½ èªªåœ¨æ‰¾é¢¨æ ¼ï¼Œå…¶å¯¦åœ¨æ‹–", "ä½œå“é›†åƒè·³èš¤å¸‚å ´", "ä½ è©²åˆªçš„æ¯”è©²ç•™çš„å¤š",
    "è®šå¤šä¸æ˜¯è­‰æ˜ï¼Œåªæ˜¯é‹æ°£", "è®šå°‘ä¹Ÿä¸ä»£è¡¨ä½ æ˜¯è—è¡“å®¶", "æ¼”ç®—æ³•ä¸æ˜¯ä½ çš„æ•µäººï¼Œæ˜¯ç…§å¦–é¡",
    "è¢«åˆ†äº«ä¸ä»£è¡¨è¢«ç†è§£", "æµé‡ä¾†å¾—å¿«ï¼Œä½ ä¹Ÿç©ºå¾—å¿«", "æ¨™ç±¤ä¸‹å¾—æº–ï¼Œç…§ç‰‡é‚„æ˜¯çˆ›",
    "æ–‡æ¡ˆæ¯”ç…§ç‰‡ç²¾å½©", "ç‚ºäº†æµé‡æ‹ï¼Œæœ€å¾Œåªå‰©æµé‡", "ç†±é–€æ§‹åœ–ä¸æ˜¯ä½ çš„é¢¨æ ¼",
    "æ¯å¼µéƒ½æƒ³çˆ†ï¼Œå…¶å¯¦æ²’ä¸€å¼µç«™å¾—ä½", "æ‹å¾ˆä¹…ï¼Œä¸ä»£è¡¨ä½ é€²æ­¥", "è€æ‰‹äº‚æ‹ï¼Œæ–°æ‰‹çœ‹ä¸å‡ºä¾†",
    "æ–°æ‰‹æ‹å¾—å¥½ï¼Œå°±æ˜¯å¥½", "è½ä¸é€²æ‰¹è©•çš„äººæœ€å±éšª", "ä¸€ç›´è¾¯è§£ï¼Œä»£è¡¨ä½ çŸ¥é“ä¸è¡Œ",
    "æ€ªå™¨æçš„äººä¸æƒ³é¢å°è‡ªå·±", "è‡ªç¨±è—è¡“å®¶çš„äººé€šå¸¸æœ€æ€•è¢«çœ‹æ‡‚", "æ”å½±ä¸æ˜¯é ­éŠœ",
    "æ‹ç…§ä¸æ˜¯é€ƒé¿æ€è€ƒ", "ç›¸æ©Ÿä¸æœƒå¹«ä½ åšé¸æ“‡", "å¥½ç…§ç‰‡ä¸ç”¨è§£é‡‹",
    "è§£é‡‹è¶Šå¤šï¼Œç…§ç‰‡è¶Šå¼±", "çœ‹ä¸å‡ºä½ æƒ³æ‹ä»€éº¼", "ã€Œæœ‰æ„Ÿè¦ºä½†èªªä¸å‡ºä¾†ã€ï¼æ²’å®Œæˆ",
    "æŠ€è¡“åˆ°ä½ï¼Œå…§å®¹ç¼ºå¸­", "æ‹å¾—æ¸…æ¥šï¼Œä¸ç­‰æ–¼æ‹å¾—å¥½", "ä½ å¾ˆåŠªåŠ›ï¼Œä½†ç…§ç‰‡æ²’æ”¶åˆ°",
    "ç›¸æ©Ÿå¾ˆé«˜ç´šï¼Œç…§ç‰‡å¾ˆæ™®é€š", "é€™å¼µä¸æ˜¯çˆ›ï¼Œæ˜¯æµªè²»", "æ²’å¤±æ•—ï¼Œä¸ä»£è¡¨æˆåŠŸ",
    "å¥½ç…§ç‰‡ä¸éœ€è¦å¾ˆå¤š", "åå¼µä¸€å¼µå°±å¾ˆå¼·", "åˆªç…§ç‰‡ä¹Ÿæ˜¯å‰µä½œ",
    "æ‹ç…§æ˜¯é¸æ“‡ï¼Œä¸æ˜¯å…¨æ”¶", "ä¸æ‹ï¼Œæœ‰æ™‚æ¯”äº‚æ‹å¥½", "ç›¸æ©Ÿæœƒéæ™‚ï¼Œçœ¼ç›ä¸æœƒ",
    "çœ‹å¾—å°‘ï¼Œæ‹å†å¤šéƒ½æ²’ç”¨", "ä½ æœ€å¾Œåªæœƒæ‹çµ¦è‡ªå·±çœ‹", "æ”å½±ä¸æ˜¯è­‰æ˜ä½ æœ‰å¤šå²å®³",
    "æ‹ç…§ï¼Œæœ€å¾Œæ˜¯åœ¨å°ä»˜è‡ªå·±"
]

# --- å“ç‰Œè©•èªè³‡æ–™åº« ---
BRAND_COMMENTS = {
    "canon": "Canonï¼ˆä½³èƒ½ï¼‰\nğŸ‘‰ ã€Œä½³èƒ½ï¼šå¤§å®¶ç¬¬ä¸€å°ç›¸æ©Ÿï¼Œè€å¸«ã€è¨˜è€…ã€å©šæ”éƒ½ç”¨å®ƒã€‚ã€",
    "nikon": "Nikonï¼ˆå°¼åº·ï¼‰\nğŸ‘‰ ã€Œå°¼åº·ï¼šæˆ‘ä¸è·Ÿæµè¡Œï¼Œæˆ‘åªè·Ÿå…‰ç·šè¬›é“ç†ã€‚ã€",
    "fujifilm": "Fujifilmï¼ˆå¯Œå£«ï¼‰\nğŸ‘‰ ã€Œå¯Œå£«ï¼šå“‡ï¼Œä½ æ˜¯å¯Œå®¶å­å¼Ÿï¼Œé€£é¡è‰²éƒ½å¾ˆæœ‰æ•™é¤Šã€‚ã€",
    "panasonic": "Panasonicï¼ˆæ¾ä¸‹ï¼‰\nğŸ‘‰ ã€Œæ¾ä¸‹ï¼šæˆ‘æ‹ç…§é‚„è¡Œï¼Œä½†æˆ‘å…¶å¯¦æ˜¯ä¾†æ‹é›»å½±çš„ã€‚ã€",
    "olympus": "OM System / Olympus\nğŸ‘‰ ã€Œå¥§æ—å·´æ–¯ï¼šæˆ‘å¾ˆå°ï¼Œä½†æˆ‘é™ªä½ ä¸Šå±±ä¸‹æµ·ã€‚ã€",
    "om digital": "OM System / Olympus\nğŸ‘‰ ã€Œå¥§æ—å·´æ–¯ï¼šæˆ‘å¾ˆå°ï¼Œä½†æˆ‘é™ªä½ ä¸Šå±±ä¸‹æµ·ã€‚ã€",
    "leica": "Leicaï¼ˆå¾ å¡ï¼‰\nğŸ‘‰ ã€Œå¾ å¡ï¼šä½ è²·çš„ä¸æ˜¯ç›¸æ©Ÿï¼Œæ˜¯ä¿¡ä»°èˆ‡ç´…é»ã€‚ã€",
    "pentax": "Pentaxï¼ˆè³“å¾—ï¼‰\nğŸ‘‰ ã€Œè³“å¾—ï¼šå¤§å®¶éƒ½å¿˜äº†æˆ‘ï¼Œä½†æˆ‘è‡ªå·±å¾ˆé©•å‚²ã€‚ã€",
    "hasselblad": "Hasselbladï¼ˆå“ˆè˜‡ï¼‰\nğŸ‘‰ ã€Œå“ˆè˜‡ï¼šæˆ‘ä¸€å¼µç…§ç‰‡ï¼Œç­‰æ–¼ä½ ä¸€å°é›»è…¦ã€‚ã€",
    "blackmagic": "Blackmagic Design\nğŸ‘‰ ã€ŒBlackmagicï¼šæ‹ç…§ï¼Ÿä¸ï¼Œæˆ‘åªæ´»åœ¨å‰ªæ¥è»Ÿé«”è£¡ã€‚ã€",
    "phase one": "Phase One\nğŸ‘‰ ã€ŒPhase Oneï¼šæ™®é€šäººä¸èªè­˜æˆ‘ï¼Œæœ‰éŒ¢äººä¸éœ€è¦è§£é‡‹ã€‚ã€",
    "gopro": "GoPro\nğŸ‘‰ ã€ŒGoProï¼šä½ åœ¨è·³å‚˜ï¼Œæˆ‘åœ¨å¹«ä½ ç•™éºç…§ã€‚ã€",
    "dji": "DJI\nğŸ‘‰ ã€ŒDJIï¼šæˆ‘æœ¬ä¾†æ˜¯ç„¡äººæ©Ÿï¼Œé †ä¾¿çµ±æ²»å½±åƒç•Œã€‚ã€",
    "insta360": "Insta360\nğŸ‘‰ ã€ŒInsta360ï¼šå…ˆæ‹å†èªªï¼Œåæ­£è§’åº¦ä¹‹å¾Œå†é¸ã€‚ã€",
    "kodak": "Kodakï¼ˆæŸ¯é”ï¼‰\nğŸ‘‰ ã€ŒæŸ¯é”ï¼šæˆ‘æ²’è½äº†ï¼Œä½†ä½ çš„é’æ˜¥æœ‰æˆ‘ã€‚ã€",
    "agfa": "AgfaPhoto\nğŸ‘‰ ã€ŒAgfaPhotoï¼šä½ ä¸çŸ¥é“æˆ‘æ˜¯èª°ï¼Œä½†æˆ‘ä¸€ç›´éƒ½åœ¨ã€‚ã€",
    "benq": "BenQï¼ˆæ˜åŸºï¼‰\nğŸ‘‰ ã€ŒBenQï¼šæˆ‘è¢å¹•å¾ˆå¼·ï¼Œç›¸æ©Ÿâ€¦ä¹Ÿç®—æœ‰èª æ„ã€‚ã€",
    "aigo": "Aigoï¼ˆæ„›åœ‹è€…ï¼‰\nğŸ‘‰ ã€ŒAigoï¼šåå­—å¾ˆç†±è¡€ï¼Œåƒ¹æ ¼æ›´ç†±è¡€ã€‚ã€",
    "flashback": "Flashback\nğŸ‘‰ ã€ŒFlashbackï¼šæˆ‘ä¸æ˜¯è€ï¼Œæ˜¯æ•…æ„å¾©å¤ã€‚ã€",
    "polaroid": "Polaroidï¼ˆå¯¶éº—ä¾†ï¼‰\nğŸ‘‰ ã€ŒPolaroidï¼šæ‹å®Œå°±å‡ºä¾†ï¼Œäººç”Ÿä¸èƒ½é‡ä¾†ã€‚ã€",
    "ricoh": "Ricohï¼ˆç†å…‰ï¼‰\nğŸ‘‰ ã€ŒRicohï¼šæ‡‚çš„äººå°±æ‡‚ï¼Œä¸æ‡‚çš„äººä¸€ç›´å•ç‚ºä»€éº¼ã€‚ã€",
    "rollei": "Rollei\nğŸ‘‰ ã€ŒRolleiï¼šå¾·åœ‹è€éˆé­‚ï¼Œæ•¸ä½æ–°èº«é«”ã€‚ã€",
    "vivitar": "Vivitar\nğŸ‘‰ ã€ŒVivitarï¼šåå­—å¾ˆéŸ¿ï¼Œå­˜åœ¨æ„Ÿå¾ˆä½›ã€‚ã€",
    "yashica": "Yashicaï¼ˆé›…è¥¿å¡ï¼‰\nğŸ‘‰ ã€ŒYashicaï¼šæˆ‘ä»¥å‰å¾ˆç´…ï¼Œç¾åœ¨é å›æ†¶ã€‚ã€",
    "z cam": "Z CAM\nğŸ‘‰ ã€ŒZ CAMï¼šä½ ä¸çŸ¥é“æˆ‘ï¼Œä½† Netflix å¯èƒ½çŸ¥é“ã€‚ã€",
    "apple": "Appleï¼ˆè˜‹æœï¼‰\nğŸ‘‰ ã€Œä½ è²·çš„ä¸æ˜¯æ‰‹æ©Ÿï¼Œæ˜¯ç”Ÿæ…‹ç³»å…¥å ´åˆ¸ã€‚ã€",
    "iphone": "Appleï¼ˆè˜‹æœï¼‰\nğŸ‘‰ ã€Œä½ è²·çš„ä¸æ˜¯æ‰‹æ©Ÿï¼Œæ˜¯ç”Ÿæ…‹ç³»å…¥å ´åˆ¸ã€‚ã€",
    "samsung": "Samsungï¼ˆä¸‰æ˜Ÿï¼‰\nğŸ‘‰ ã€Œå‹è™Ÿå¤šåˆ°é€£è‡ªå·±éƒ½éœ€è¦åˆ†é¡è¡¨ã€‚ã€",
    "google": "Googleï¼ˆPixelï¼‰\nğŸ‘‰ ã€Œç¡¬é«”æ™®é€šï¼Œä½†æˆ‘æ˜¯ AI è¦ªå…’å­ã€‚ã€",
    "pixel": "Googleï¼ˆPixelï¼‰\nğŸ‘‰ ã€Œç¡¬é«”æ™®é€šï¼Œä½†æˆ‘æ˜¯ AI è¦ªå…’å­ã€‚ã€",
    "xiaomi": "Xiaomiï¼ˆå°ç±³ï¼‰\nğŸ‘‰ ã€Œè¦æ ¼çµ¦æ»¿ï¼Œåƒ¹æ ¼çµ¦ç”œï¼Œåå­—ä¸€ç›´æ”¹ã€‚ã€",
    "oneplus": "OnePlusï¼ˆä¸€åŠ ï¼‰\nğŸ‘‰ ã€Œç•¶å¹´æ——è‰¦æ®ºæ‰‹ï¼Œç¾åœ¨è‡ªå·±è®Šæ——è‰¦ã€‚ã€",
    "motorola": "Motorolaï¼ˆæ‘©æ‰˜ç¾…æ‹‰ï¼‰\nğŸ‘‰ ã€Œæˆ‘é‚„æ´»è‘—ï¼Œè€Œä¸”æˆ‘æœƒæŠ˜ã€‚ã€",
    "vivo": "vivo\nğŸ‘‰ ã€Œæ‹äººåƒå¾ˆç¾ï¼Œåå­—æ°¸é æ‰“å°å¯«ã€‚ã€",
    "oppo": "OPPO\nğŸ‘‰ ã€Œå……é›»å¿«åˆ°ä½ é‚„æ²’æ‰¾å¥½æ’åº§å°±æ»¿äº†ã€‚ã€",
    "realme": "Realme\nğŸ‘‰ ã€Œæˆ‘å¹´è¼•ã€æˆ‘ä¾¿å®œã€æˆ‘ä¸€ç›´å‡ºæ–°æ©Ÿã€‚ã€",
    "iqoo": "iQOO\nğŸ‘‰ ã€Œæ€§èƒ½æ€ªç¸ï¼Œä½†åå­—åƒé›»ç«¶éšŠä¼ã€‚ã€",
    "nothing": "Nothing\nğŸ‘‰ ã€Œæˆ‘ä»€éº¼éƒ½æ²’æœ‰ï¼Œä½†ä½ å°±æ˜¯æœƒå¤šçœ‹å…©çœ¼ã€‚ã€",
    "infinix": "Infinix\nğŸ‘‰ ã€Œè¦æ ¼å¯«å¾—å¾ˆçŒ›ï¼Œåƒ¹æ ¼ä½åˆ°ä¸åƒçœŸçš„ã€‚ã€",
    "tecno": "Tecno\nğŸ‘‰ ã€Œä½ å¯èƒ½æ²’è½éæˆ‘ï¼Œä½†æˆ‘è³£å¾—æ¯”ä½ æƒ³åƒå¤šã€‚ã€",
    "honor": "Honorï¼ˆæ¦®è€€ï¼‰\nğŸ‘‰ ã€Œæˆ‘ä¸æ˜¯è¯ç‚ºï¼Œä½†å¤§å®¶ä¸€ç›´é€™æ¨£çœ‹æˆ‘ã€‚ã€",
    "nokia": "Nokiaï¼ˆè«¾åŸºäºï¼‰\nğŸ‘‰ ã€Œæ‰‹æ©Ÿæœƒå£ï¼Œä½†æˆ‘ä¸æœƒå€’ã€‚ã€",
    "htc": "HTC\nğŸ‘‰ ã€Œæˆ‘æ›¾ç¶“ç«™åœ¨ä¸–ç•Œä¹‹å·”ã€‚ã€"
}

class ModernExifApp(TkinterDnD.Tk):
    def __init__(self):
        super().__init__()

        self.title("Kuso EXIF æª¢è¦–å™¨ (V1.0 20251230)")
        self.geometry("1000x950")
        self.configure(bg=CYBER_DARK)

        self.current_image_path = None
        self.exif_data_cache = {}
        self.image_list = []
        self.current_index = -1
        self.popup_window = None

        # --- é ‚éƒ¨ Header ---
        self.header_label = ctk.CTkLabel(
            self, 
            text="[ Kuso EXIF æª¢è¦–å™¨ (V1.0 20251230) ]", 
            font=FONT_DATA,
            text_color=CYBER_CYAN,
            fg_color=CYBER_DARK,
            height=30
        )
        self.header_label.pack(side="top", fill="x", pady=(10,0))

        # --- ä¸»å®¹å™¨ ---
        self.main_container = ctk.CTkFrame(self, fg_color="transparent")
        self.main_container.pack(fill="both", expand=True)

        self.main_container.grid_columnconfigure(0, weight=1)
        self.main_container.grid_columnconfigure(1, weight=1)
        self.main_container.grid_rowconfigure(0, weight=3)
        self.main_container.grid_rowconfigure(1, weight=0)
        self.main_container.grid_rowconfigure(2, weight=2)
        self.main_container.grid_rowconfigure(3, weight=0)

        # 1. åœ–ç‰‡é è¦½å€
        self.frame_preview = ctk.CTkFrame(
            self.main_container, 
            corner_radius=8, 
            fg_color=CYBER_BG_FRAME, 
            border_color=CYBER_CYAN,
            border_width=2
        )
        self.frame_preview.grid(row=0, column=0, columnspan=2, padx=20, pady=(20, 10), sticky="nsew")
        
        self.lbl_preview_hint = ctk.CTkLabel(
            self.frame_preview, 
            text=">> æ‹–æ›³å½±åƒè³‡æ–™è‡³æ­¤è¼‰å…¥ <<", 
            font=FONT_TITLE, 
            text_color=CYBER_CYAN
        )
        self.lbl_preview_hint.place(relx=0.5, rely=0.5, anchor="center")

        self.lbl_image = ctk.CTkLabel(self.frame_preview, text="", cursor="hand2")
        self.lbl_image.place(relx=0.5, rely=0.5, anchor="center")
        
        self.lbl_image.bind("<Button-1>", self.open_original_file)
        self.lbl_image.bind("<Enter>", self.on_image_hover_enter)
        self.lbl_image.bind("<Leave>", self.on_image_hover_leave)
        self.lbl_image.bind("<Motion>", self.on_image_hover_motion)

        self.lbl_hover_text = ctk.CTkLabel(
            self, 
            text="[ è­¦å‘Šï¼šåµæ¸¬åˆ°æ‰‹æŒ‡è¼¸å…¥ ]\né»å•Šï¼Œä½ çµ¦æˆ‘é»å•Š", 
            font=FONT_HEADER,
            fg_color=CYBER_YELLOW,
            text_color=CYBER_DARK,
            corner_radius=4,
            width=200
        )

        # 1.5 é€²åº¦æ¢
        self.progress_bar = ctk.CTkProgressBar(
            self.main_container, 
            orientation="horizontal", 
            mode="indeterminate", 
            height=8,
            fg_color=CYBER_DARK,
            progress_color=CYBER_CYAN,
            border_color=CYBER_CYAN,
            border_width=1
        )
        self.progress_bar.grid(row=1, column=0, columnspan=2, padx=25, pady=(0, 10), sticky="ew")
        self.progress_bar.grid_remove()

        # 2. è£å‚™æ¸…å–®
        self.frame_basic = ctk.CTkFrame(
            self.main_container, 
            corner_radius=8, 
            fg_color=CYBER_BG_FRAME, 
            border_color=CYBER_YELLOW,
            border_width=2
        )
        self.frame_basic.grid(row=2, column=0, padx=(20, 10), pady=(0, 20), sticky="nsew")

        ctk.CTkLabel(self.frame_basic, text="[ è£å‚™æ¸…å–® // GEAR_LIST ]", text_color=CYBER_YELLOW, font=FONT_HEADER).pack(pady=10)
        
        self.txt_basic = ctk.CTkTextbox(
            self.frame_basic, 
            font=FONT_DATA,
            text_color=CYBER_TEXT_MAIN, 
            fg_color="transparent"
        )
        self.txt_basic.pack(fill="both", expand=True, padx=15, pady=10)
        self.create_context_menu(self.txt_basic)
        self.txt_basic._textbox.tag_config("quote_style", font=FONT_QUOTE, foreground=CYBER_YELLOW)

        # 3. å‰ä¸–ä»Šç”Ÿ
        self.frame_exposure = ctk.CTkFrame(
            self.main_container, 
            corner_radius=8, 
            fg_color=CYBER_BG_FRAME, 
            border_color=CYBER_PINK,
            border_width=2
        )
        self.frame_exposure.grid(row=2, column=1, padx=(10, 20), pady=(0, 20), sticky="nsew")

        ctk.CTkLabel(self.frame_exposure, text="[ å‰ä¸–ä»Šç”Ÿ // EXPOSURE_DATA ]", text_color=CYBER_PINK, font=FONT_HEADER).pack(pady=10)
        
        self.txt_exposure = ctk.CTkTextbox(
            self.frame_exposure, 
            font=FONT_DATA, 
            text_color=CYBER_TEXT_MAIN, 
            fg_color="transparent"
        )
        self.txt_exposure.pack(fill="both", expand=True, padx=15, pady=10)
        self.create_context_menu(self.txt_exposure)

        # 4. æŒ‰éˆ•å€
        self.frame_controls = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.frame_controls.grid(row=3, column=0, columnspan=2, padx=20, pady=(0, 20), sticky="ew")
        self.frame_controls.grid_columnconfigure(0, weight=1)
        self.frame_controls.grid_columnconfigure(1, weight=2)
        self.frame_controls.grid_columnconfigure(2, weight=1)

        btn_style = {"font": FONT_BUTTON, "height": 50, "corner_radius": 8, "text_color": CYBER_DARK}

        self.btn_prev = ctk.CTkButton(
            self.frame_controls, text="< ä¸Šä¸€å¼µ", **btn_style,
            fg_color=CYBER_CYAN, hover_color="#00cccc",
            command=self.load_prev_image
        )
        self.btn_prev.grid(row=0, column=0, padx=5, sticky="ew")

        self.btn_export = ctk.CTkButton(
            self.frame_controls, text=">> è¼¸å‡ºç…§ç‰‡èº«ä»½è­‰ <<", **btn_style,
            fg_color=CYBER_GREEN, hover_color="#2ecc71",
            command=self.export_to_txt
        )
        self.btn_export.grid(row=0, column=1, padx=5, sticky="ew")

        self.btn_next = ctk.CTkButton(
            self.frame_controls, text="ä¸‹ä¸€å¼µ >", **btn_style,
            fg_color=CYBER_CYAN, hover_color="#00cccc",
            command=self.load_next_image
        )
        self.btn_next.grid(row=0, column=2, padx=5, sticky="ew")
        
        # --- è¯çµ¡è³‡è¨Š ---
        self.lbl_contact = ctk.CTkLabel(
            self, 
            text="ç¨‹å¼è¨­è¨ˆï¼šè³€ç¦ç¦æ”å½±æ•™å®¤\né€£çµ¡æ–¹å¼ï¼šhojenjen2018@gmail.com", 
            font=("Microsoft JhengHei UI", 12), 
            text_color="#888888"
        )
        self.lbl_contact.pack(side="bottom", pady=(0, 10))

        # --- åº•éƒ¨ç‹€æ…‹åˆ— ---
        self.status_label = ctk.CTkLabel(
            self, text="SYSTEM STATUS: WAITING FOR INPUT...", 
            font=("Consolas", 10), text_color=CYBER_CYAN, anchor="w"
        )
        self.status_label.pack(side="bottom", fill="x", padx=20, pady=(0, 5))

        # --- ç¶å®š ---
        self.drop_target_register(DND_FILES)
        self.dnd_bind('<<Drop>>', self.on_drop)
        self.bind("<Left>", lambda e: self.load_prev_image())
        self.bind("<Up>", lambda e: self.load_prev_image())
        self.bind("<Right>", lambda e: self.load_next_image())
        self.bind("<Down>", lambda e: self.load_next_image())

    # --- éš¨æ©Ÿé‡‘å¥å½ˆè·³è¦–çª— ---
    def show_random_quote(self):
        if self.popup_window is not None and self.popup_window.winfo_exists():
            self.popup_window.destroy()

        quote = random.choice(SOUL_QUOTES)

        self.popup_window = ctk.CTkToplevel(self)
        self.popup_window.title("CYBER_SYSTEM_ALERT")
        self.popup_window.overrideredirect(True) 
        self.popup_window.attributes("-topmost", True)
        self.popup_window.configure(bg=CYBER_DARK)
        
        w, h = 600, 250
        x = self.winfo_x() + (self.winfo_width() // 2) - (w // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (h // 2)
        self.popup_window.geometry(f"{w}x{h}+{x}+{y}")
        
        frame = ctk.CTkFrame(
            self.popup_window, 
            fg_color=CYBER_BG_FRAME, 
            border_width=3, 
            border_color=CYBER_PINK,
            corner_radius=0
        )
        frame.pack(expand=True, fill="both")

        label_title = ctk.CTkLabel(
            frame, 
            text="// SYSTEM_OVERRIDE // éˆé­‚æ‹·å•ç¨‹åºå•Ÿå‹• //", 
            font=FONT_DATA, 
            text_color=CYBER_PINK
        )
        label_title.pack(pady=(20, 10))

        label_quote = ctk.CTkLabel(
            frame, 
            text=quote, 
            font=FONT_QUOTE, 
            text_color=CYBER_TEXT_MAIN,
            wraplength=550
        )
        label_quote.pack(expand=True)

        # é€™è£¡å¼·åˆ¶è¨­å®šç‚º é»ƒè‰²(#FFFF00) ä¸” å­—é«”è®Šå¤§(18 bold)
        label_hint = ctk.CTkLabel(
            frame, 
            text="[ é»æ“Šä»»æ„è™•é—œé–‰ ]", 
            font=("Microsoft JhengHei UI", 18, "bold"), 
            text_color="#FFFF00"
        )
        label_hint.pack(pady=(10, 20))

        def close_popup(event):
            self.popup_window.destroy()
        
        for widget in [self.popup_window, frame, label_quote, label_title, label_hint]:
            widget.bind("<Button-1>", close_popup)

        self.popup_window.lift()
        self.popup_window.focus_force()
        self.popup_window.grab_set()
        self.popup_window.update()

    # --- æ»‘é¼ æ‡¸åœé‚è¼¯ ---
    def on_image_hover_enter(self, event):
        if self.current_image_path:
            self.lbl_hover_text.lift()
            self.lbl_hover_text.place(x=event.x_root - self.winfo_rootx() + 20, y=event.y_root - self.winfo_rooty() + 20)

    def on_image_hover_leave(self, event):
        self.lbl_hover_text.place_forget()

    def on_image_hover_motion(self, event):
        if self.current_image_path:
            x = event.x_root - self.winfo_rootx() + 25
            y = event.y_root - self.winfo_rooty() + 10
            self.lbl_hover_text.place(x=x, y=y)

    # --- å³éµé¸å–® ---
    def create_context_menu(self, widget):
        menu = Menu(self, tearoff=0, bg=CYBER_BG_FRAME, fg=CYBER_CYAN, activebackground=CYBER_CYAN, activeforeground=CYBER_DARK)
        menu.add_command(label=">> è¤‡è£½æ•¸å€¼", command=lambda: self.copy_selection(widget))
        menu.add_separator()
        menu.add_command(label=">> è¼¸å‡ºé¸å–å…§å®¹è‡³ TXT", command=lambda: self.export_selection(widget))
        def show_menu(event):
            try: menu.tk_popup(event.x_root, event.y_root)
            finally: menu.grab_release()
        widget.bind("<Button-3>", show_menu)
        if platform.system() == 'Darwin': widget.bind("<Button-2>", show_menu)

    def copy_selection(self, widget):
        try:
            self.clipboard_clear()
            self.clipboard_append(widget.get("sel.first", "sel.last"))
        except: pass

    def export_selection(self, widget):
        try:
            txt = widget.get("sel.first", "sel.last")
            if not txt: return
            path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt")])
            if path:
                with open(path, "w", encoding="utf-8") as f: f.write(txt)
                messagebox.showinfo("SYSTEM", "æª”æ¡ˆå·²è¼¸å‡ºï¼Œå»æ‰¾å§ï¼Œæˆ‘éƒ½å­˜åœ¨ one peaceäº†")
        except: pass

    # --- åœ–ç‰‡è™•ç† (å¤šåŸ·è¡Œç·’ç‰ˆ) ---
    def on_drop(self, event):
        file_path = event.data
        if file_path.startswith('{') and file_path.endswith('}'):
            file_path = file_path[1:-1]
        if os.path.isfile(file_path):
            self.process_new_file(file_path)

    def process_new_file(self, path):
        folder = os.path.dirname(path)
        valid_exts = ['*.jpg', '*.jpeg', '*.png', '*.tiff', '*.webp', '*.JPG', '*.JPEG', '*.PNG']
        self.image_list = []
        for ext in valid_exts:
            self.image_list.extend(glob.glob(os.path.join(folder, ext)))
        self.image_list.sort()
        try: self.current_index = self.image_list.index(path)
        except ValueError: self.current_index = 0
        
        self.start_loading_sequence(path)

    def start_loading_sequence(self, path):
        self.status_label.configure(text=f"ANALYZING TARGET: {os.path.basename(path)}... [BACKGROUND_TASK_INIT]")
        self.progress_bar.grid()
        self.progress_bar.start()
        
        thread = threading.Thread(target=self.run_background_loading, args=(path,), daemon=True)
        thread.start()

    def run_background_loading(self, path):
        try:
            pil_img = Image.open(path)
            pil_img.load() 
            
            orig_width, orig_height = pil_img.size
            file_size_mb = os.path.getsize(path) / (1024 * 1024)
            exif_raw = pil_img._getexif()

            # é‡é»ä¿®æ­£ï¼šåœ¨å¾Œå°åŸ·è¡Œç¸®åœ–ï¼Œä¸»åŸ·è¡Œç·’åªè² è²¬é¡¯ç¤ºå°åœ–
            # é™åˆ¶ç‚º 500x500 ä»¥å…§ï¼Œé€™æ¨£å‚³å› UI æ™‚å°±ä¸æœƒå¡é “
            preview_img = pil_img.copy()
            preview_img.thumbnail((500, 500)) 

            parsed_data = self.parse_exif_data_only(exif_raw, orig_width, orig_height, file_size_mb, path)
            
            # å°‡ç¸®å¥½çš„ preview_img å‚³çµ¦ä¸»ç·šç¨‹
            self.after(0, lambda: self.update_ui_after_loading(preview_img, parsed_data))

        except Exception as e:
            self.after(0, lambda: self.handle_loading_error(e))

    def update_ui_after_loading(self, pil_img, parsed_data):
        try:
            self.current_image_path = parsed_data['path']
            
            # é€™è£¡æ‹¿åˆ°çš„ pil_img å·²ç¶“æ˜¯ç¸®å°çš„ç¸®åœ–äº†ï¼Œæ‰€ä»¥ CTkImage è™•ç†å¾ˆå¿«
            display_img = ctk.CTkImage(light_image=pil_img, dark_image=pil_img, size=(500, 350))
            self.lbl_image.configure(image=display_img, text="")
            self.lbl_preview_hint.place_forget()

            self.txt_basic.delete("0.0", "end")
            self.txt_basic.insert("end", parsed_data['basic_text'])
            if parsed_data['brand_quote']:
                self.txt_basic.insert("end", parsed_data['brand_quote'] + "\n", "quote_style")

            self.txt_exposure.delete("0.0", "end")
            self.txt_exposure.insert("0.0", parsed_data['exposure_text'])

            self.exif_data_cache = {
                "basic": parsed_data['basic_text'] + parsed_data['brand_quote'],
                "exposure": parsed_data['exposure_text'],
                "filename": os.path.basename(self.current_image_path)
            }

            self.progress_bar.stop()
            self.progress_bar.grid_remove()
            self.status_label.configure(text="ANALYSIS COMPLETE. DATA READY.")
            self.focus_set()
            self.show_random_quote()

        except Exception as e:
            self.handle_loading_error(e)

    def handle_loading_error(self, e):
        self.progress_bar.stop()
        self.progress_bar.grid_remove()
        self.status_label.configure(text=f"ERROR: {e}")

    def load_prev_image(self):
        if not self.image_list: return
        self.current_index = (self.current_index - 1) % len(self.image_list)
        path = self.image_list[self.current_index]
        self.start_loading_sequence(path)

    def load_next_image(self):
        if not self.image_list: return
        self.current_index = (self.current_index + 1) % len(self.image_list)
        path = self.image_list[self.current_index]
        self.start_loading_sequence(path)

    def parse_exif_data_only(self, exif_raw, width, height, size_mb, path):
        data = {}
        if exif_raw:
            for tag_id, value in exif_raw.items():
                data[ExifTags.TAGS.get(tag_id, tag_id)] = value

        exp_mode_str = "ä½ äº‚æ‹å°å§?"
        if 'ExposureProgram' in data:
            try:
                mode_val = int(data['ExposureProgram'])
                if mode_val == 1: exp_mode_str = "M = Magic Modeï¼ˆé­”æ³•æ¨¡å¼ï¼‰ ğŸ‘‰ æ–°æ‰‹ä»¥ç‚ºé€²å»æœƒè‡ªå‹•è®Šå¼·"
                elif mode_val == 2: exp_mode_str = "P = Pray Modeï¼ˆç¥ˆç¦±æ¨¡å¼ï¼‰ ğŸ‘‰ å¸Œæœ›ç›¸æ©Ÿæ‡‚æˆ‘"
                elif mode_val == 3: exp_mode_str = "Av = Art Vision æ¨¡å¼ï¼ˆè—è¡“è¦–è§’ï¼‰ ğŸ‘‰ èƒŒæ™¯èƒ½ç³Šå°±æ˜¯å¥½ç…§ç‰‡"
                elif mode_val == 4: exp_mode_str = "S = Stop That Motion æ¨¡å¼ ğŸ‘‰ ä¸å‡†å‹•ï¼"
                elif mode_val == 0: exp_mode_str = "Auto = Blame the Camera Modeï¼ˆå‡ºäº‹æ€ªç›¸æ©Ÿï¼‰"
                else: exp_mode_str = "Auto = Blame the Camera Modeï¼ˆå‡ºäº‹æ€ªç›¸æ©Ÿï¼‰"
            except: pass
        
        date_analysis = self.analyze_date_sentiment(data.get('DateTime', ''))

        wb_map = {0: "è‡ªå‹•", 1: "æ‰‹å‹•"}
        wb_str = "è‰²å½©ä¸é‡è¦"
        if 'WhiteBalance' in data:
            try: wb_str = wb_map.get(int(data.get('WhiteBalance')), "å…¶ä»–")
            except: pass

        raw_shutter = data.get('ExposureTime', 0)
        shutter_str = "åˆ¥çœ‹é€™ï¼Œæ²’è³‡æ–™"
        try:
            val = float(raw_shutter)
            if val > 0:
                if val < 1: shutter_str = f"1/{round(1/val)}"
                else: shutter_str = f"{int(val) if val.is_integer() else val} ç§’"
        except: pass

        raw_f = data.get('FNumber', 0)
        f_str = "å¤§æ¦‚æ²’è£é¡é ­å§?"
        try: val = float(raw_f); f_str = f"f/{val}" if val > 0 else f_str
        except: pass

        raw_fl = data.get('FocalLength', 0)
        fl_str = "æˆ‘ç´¯äº†"
        try: val = float(raw_fl); fl_str = f"{val} mm" if val > 0 else fl_str
        except: pass

        hyper_str = "é€™ä½ ä¸éœ€è¦çŸ¥é“ï¼Œåæ­£ä½ ä¹Ÿä¸åœ¨ä¹"
        try:
            fl = float(data.get('FocalLength', 0))
            fn = float(data.get('FNumber', 0))
            if fl > 0 and fn > 0:
                hyper_str = f"{((fl**2)/(fn*0.03)+fl)/1000:.2f} m"
        except: pass

        iso_val = data.get('ISOSpeedRatings', None)
        iso_str = f"ISO {iso_val}" if iso_val else "æˆ‘è®€ä¸åˆ°åˆ¥å•æˆ‘"

        gps_tag = next((k for k, v in ExifTags.TAGS.items() if v == 'GPSInfo'), None)
        gps_str = "åŒ…å«åº§æ¨™æ•¸æ“š" if (exif_raw and gps_tag in exif_raw) else "æˆ‘æ²’æœ‰ GPS ï¼Œä½ åˆ¥çœ‹äº†"

        raw_make = str(data.get('Make', '')).strip()
        raw_model = str(data.get('Model', '')).strip()
        cam_name = f"{raw_make} {raw_model}".strip() if raw_make or raw_model else "æˆ‘æ²’æœ‰åå­—"
        lens_name = f"{data.get('LensMake', '')} {data.get('LensModel', '')}".strip()
        if not lens_name: lens_name = "æˆ‘æ²’æœ‰çœ¼é¡"

        brand_quote = self.get_brand_quote(raw_make, raw_model)

        basic_text = (
            f"DEVICE_NAME : {cam_name}\n"
            f"LENS_MODEL  : {lens_name}\n"
            f"CAPTURE_DATE: {date_analysis}\n"
            f"\nRESOLUTION  : {width} x {height} ({round((width*height)/1000000, 1)} MP)\n"
            f"FILE_SIZE   : {size_mb:.2f} MB\n"
            f"GPS_STATUS  : {gps_str}\n"
            f"\n{'='*30}\n"
        )

        exposure_text = (
            f"EXP_MODE    : {exp_mode_str}\n"
            f"ISO_SPEED   : {iso_str}\n"
            f"SHUTTER     : {shutter_str}\n"
            f"APERTURE    : {f_str}\n"
            f"FOCAL_LEN   : {fl_str}\n"
            f"WHITE_BAL   : {wb_str}\n"
            f"HYPERFOCAL  : {hyper_str}\n"
        )

        return {
            "basic_text": basic_text,
            "exposure_text": exposure_text,
            "brand_quote": brand_quote,
            "path": path
        }

    def get_brand_quote(self, make, model):
        make_s = str(make).lower().strip()
        model_s = str(model).lower().strip()
        if "sony" in make_s:
            return "Sonyï¼ˆç´¢å°¼ï¼‰\nğŸ‘‰ ã€Œç›¸æ©Ÿéƒ¨é–€å¾ˆå¼·ï¼Œä½†æ‰‹æ©Ÿåªæƒ³åšçµ¦æ‡‚çš„äººã€‚ã€" if "xperia" in model_s else "Sonyï¼ˆç´¢å°¼ï¼‰\nğŸ‘‰ ã€ŒSonyï¼šå°ç„¦æ¯”ä½ äººç”Ÿç›®æ¨™é‚„å¿«ã€‚ã€"
        for k, v in BRAND_COMMENTS.items():
            if k in make_s: return v
        return ""

    def analyze_date_sentiment(self, date_str):
        if not date_str or str(date_str).strip() == "": return "æˆ‘æ²’æœ‰ç”Ÿæ—¥"
        try:
            dt_obj = datetime.strptime(str(date_str), '%Y:%m:%d %H:%M:%S')
            year = dt_obj.year
            main_date = f"{dt_obj.year}-{dt_obj.month:02d}-{dt_obj.day:02d}"
            
            if year >= 2024: comment = "ã€Œé‚„åœ¨ä¿å›ºå…§ã€\nğŸ‘‰ è¨˜æ†¶æ–°é®®ã€ç¡¬ç¢Ÿé‚„æ²’å£\nğŸ‘‰ ã€Œé€™ä¸æ˜¯èˆŠç…§ï¼Œæ˜¯å›é¡§ã€"
            elif year >= 2023: comment = "ã€Œæ™‚é–“éå¥½å¿«æ¨¡å¼ã€\nğŸ‘‰ æ‹çš„æ™‚å€™æ˜æ˜æ˜¯æ˜¨å¤©\nğŸ‘‰ ã€Œæ€éº¼å·²ç¶“å…©å¹´äº†ï¼Ÿã€"
            elif year >= 2022: comment = "ã€Œç–«æƒ…å¾Œéºç…§ï¼ˆæƒ…æ„Ÿç‰ˆï¼‰ã€\nğŸ‘‰ äººé‚„åœ¨ï¼Œæ„Ÿè¦ºä¸ä¸€æ¨£äº†\nğŸ‘‰ ã€Œé‚£æ™‚å€™çš„æˆ‘ï¼Œå¥½ç˜¦ / å¥½å¤©çœŸã€"
            elif year >= 2021: comment = "ã€Œæ™‚ä»£äº¤ç•Œç·šã€\nğŸ‘‰ æ‹ç…§è¨­å‚™å·²è¢«å«ŒèˆŠ\nğŸ‘‰ ã€Œé€™æ˜¯å‰ä¸€æ”¯æ‰‹æ©Ÿæ‹çš„ã€"
            elif year >= 2020: comment = "ã€Œå“‡é ï¼Œå·²ç¶“äº”å¹´äº†ã€\nğŸ‘‰ æ­£å¼é€²å…¥æ‡·èˆŠå€\nğŸ‘‰ ã€Œé€™å¼µç¾åœ¨çœ‹æœ‰é»æ„Ÿæƒ…ã€"
            elif year >= 2015: comment = "ã€Œç¶“å…¸è€ç…§ç‰‡ã€\nğŸ‘‰ æ¿¾é¡é–‹å§‹æœ‰å¹´ä»£æ„Ÿ\nğŸ‘‰ ã€Œé€™æ˜¯æˆ‘ä»¥å‰çš„é¢¨æ ¼ã€ï¼ˆ= ä¸æƒ³æ‰¿èªï¼‰"
            elif year >= 2000: comment = "ã€Œæ­·å²æ–‡ä»¶ç­‰ç´šã€\nğŸ‘‰ äººç‰©å¤–å‹å·®å¾ˆå¤š\nğŸ‘‰ ã€Œé‚£æ™‚å€™å¤§å®¶éƒ½é€™æ¨£ç©¿ã€"
            else: comment = "ã€Œè€ƒå¤ç¾å ´ã€\nğŸ‘‰ ç•«è³ªæ„Ÿäººã€è¡¨æƒ…çœŸèª \nğŸ‘‰ ã€Œé€™å¼µè¦å°å¿ƒæ‹¿ã€"
            
            return f"{main_date}\n\n[ æ™‚å…‰æ©Ÿåˆ†æ // TIME_MACHINE_LOG ]\n{comment}"
        except: return f"{date_str} (DATA CORRUPTED)"

    def open_original_file(self, event):
        if self.current_image_path:
            try:
                if platform.system() == 'Darwin': os.system(f'open "{self.current_image_path}"')
                elif platform.system() == 'Windows': os.startfile(self.current_image_path)
                else: os.system(f'xdg-open "{self.current_image_path}"')
            except Exception as e: 
                self.status_label.configure(text=f"ERROR OPENING FILE: {e}")

    def export_to_txt(self):
        if not self.exif_data_cache: return
        file_name = self.exif_data_cache.get('filename', 'exif_info')
        save_path = filedialog.asksaveasfilename(
            initialfile=f"{file_name}_DATA_LOG.txt", defaultextension=".txt",
            filetypes=[("Text Documents", "*.txt")]
        )
        if save_path:
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(f"// CYBERDECK EXIF ANALYSIS LOG //\n")
                f.write(f"TARGET_FILE: {self.exif_data_cache['filename']}\n\n")
                f.write(f"[ GEAR_LIST ]\n{self.exif_data_cache['basic']}\n")
                f.write(f"[ EXPOSURE_DATA ]\n{self.exif_data_cache['exposure']}\n")
            messagebox.showinfo("SYSTEM", "æª”æ¡ˆå·²è¼¸å‡ºï¼Œå»æ‰¾å§ï¼Œæˆ‘éƒ½å­˜åœ¨ one peaceäº†")

if __name__ == "__main__":
    app = ModernExifApp()
    app.mainloop()